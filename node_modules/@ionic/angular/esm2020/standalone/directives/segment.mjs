import { ChangeDetectionStrategy, Component, HostListener, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { ValueAccessor } from '@ionic/angular/common';
import { defineCustomElement } from '@ionic/core/components/ion-segment.js';
/**
 * Value accessor components should not use ProxyCmp
 * and should call defineCustomElement and proxyInputs
 * manually instead. Using both the @ProxyCmp and @Component
 * decorators and useExisting (where useExisting refers to the
 * class) causes ng-packagr to output multiple component variables
 * which breaks treeshaking.
 * For example, the following would be generated:
 * let IonSegment = IonSegment_1 = class IonSegment extends ValueAccessor {
 * Instead, we want only want the class generated:
 * class IonSegment extends ValueAccessor {
 */
import { proxyInputs, proxyOutputs } from './angular-component-lib/utils';
import * as i0 from "@angular/core";
const SEGMENT_INPUTS = ['color', 'disabled', 'mode', 'scrollable', 'selectOnFocus', 'swipeGesture', 'value'];
export class IonSegment extends ValueAccessor {
    constructor(c, r, z, injector) {
        super(injector, r);
        this.z = z;
        defineCustomElement();
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange']);
    }
    ngOnInit() {
        /**
         * Data-bound input properties are set
         * by Angular after the constructor, so
         * we need to run the proxy in ngOnInit.
         */
        proxyInputs(IonSegment, SEGMENT_INPUTS);
    }
    handleIonChange(el) {
        this.handleValueChange(el, el.value);
    }
}
/** @nocollapse */ IonSegment.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IonSegment, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ IonSegment.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: IonSegment, isStandalone: true, selector: "ion-segment", inputs: { color: "color", disabled: "disabled", mode: "mode", scrollable: "scrollable", selectOnFocus: "selectOnFocus", swipeGesture: "swipeGesture", value: "value" }, host: { listeners: { "ionChange": "handleIonChange($event.target)" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: IonSegment,
            multi: true,
        },
    ], usesInheritance: true, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IonSegment, decorators: [{
            type: Component,
            args: [{
                    selector: 'ion-segment',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
                    inputs: SEGMENT_INPUTS,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IonSegment,
                            multi: true,
                        },
                    ],
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Injector }]; }, propDecorators: { handleIonChange: [{
                type: HostListener,
                args: ['ionChange', ['$event.target']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VnbWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3N0YW5kYWxvbmUvc3JjL2RpcmVjdGl2ZXMvc2VnbWVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBRXZCLFNBQVMsRUFHVCxZQUFZLEdBR2IsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXRELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBRTVFOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsT0FBTyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQzs7QUFFMUUsTUFBTSxjQUFjLEdBQUcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsZUFBZSxFQUFFLGNBQWMsRUFBRSxPQUFPLENBQUMsQ0FBQztBQWlCN0csTUFBTSxPQUFPLFVBQVcsU0FBUSxhQUFhO0lBRTNDLFlBQVksQ0FBb0IsRUFBRSxDQUFhLEVBQVksQ0FBUyxFQUFFLFFBQWtCO1FBQ3RGLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFEc0MsTUFBQyxHQUFELENBQUMsQ0FBUTtRQUVsRSxtQkFBbUIsRUFBRSxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNYLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLGFBQWEsQ0FBQztRQUMxQixZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRCxRQUFRO1FBQ047Ozs7V0FJRztRQUNILFdBQVcsQ0FBQyxVQUFVLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUdELGVBQWUsQ0FBQyxFQUF5QjtRQUN2QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QyxDQUFDOzsySEF0QlUsVUFBVTsrR0FBVixVQUFVLDBTQVRWO1FBQ1Q7WUFDRSxPQUFPLEVBQUUsaUJBQWlCO1lBQzFCLFdBQVcsRUFBRSxVQUFVO1lBQ3ZCLEtBQUssRUFBRSxJQUFJO1NBQ1o7S0FDRixpREFUUywyQkFBMkI7NEZBWTFCLFVBQVU7a0JBZnRCLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGFBQWE7b0JBQ3ZCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxRQUFRLEVBQUUsMkJBQTJCO29CQUNyQyx1RUFBdUU7b0JBQ3ZFLE1BQU0sRUFBRSxjQUFjO29CQUN0QixTQUFTLEVBQUU7d0JBQ1Q7NEJBQ0UsT0FBTyxFQUFFLGlCQUFpQjs0QkFDMUIsV0FBVyxZQUFZOzRCQUN2QixLQUFLLEVBQUUsSUFBSTt5QkFDWjtxQkFDRjtvQkFDRCxVQUFVLEVBQUUsSUFBSTtpQkFDakI7NktBcUJDLGVBQWU7c0JBRGQsWUFBWTt1QkFBQyxXQUFXLEVBQUUsQ0FBQyxlQUFlLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0TGlzdGVuZXIsXG4gIEluamVjdG9yLFxuICBOZ1pvbmUsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgVmFsdWVBY2Nlc3NvciB9IGZyb20gJ0Bpb25pYy9hbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgdHlwZSB7IFNlZ21lbnRDaGFuZ2VFdmVudERldGFpbCwgQ29tcG9uZW50cyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNlZ21lbnQuanMnO1xuXG4vKipcbiAqIFZhbHVlIGFjY2Vzc29yIGNvbXBvbmVudHMgc2hvdWxkIG5vdCB1c2UgUHJveHlDbXBcbiAqIGFuZCBzaG91bGQgY2FsbCBkZWZpbmVDdXN0b21FbGVtZW50IGFuZCBwcm94eUlucHV0c1xuICogbWFudWFsbHkgaW5zdGVhZC4gVXNpbmcgYm90aCB0aGUgQFByb3h5Q21wIGFuZCBAQ29tcG9uZW50XG4gKiBkZWNvcmF0b3JzIGFuZCB1c2VFeGlzdGluZyAod2hlcmUgdXNlRXhpc3RpbmcgcmVmZXJzIHRvIHRoZVxuICogY2xhc3MpIGNhdXNlcyBuZy1wYWNrYWdyIHRvIG91dHB1dCBtdWx0aXBsZSBjb21wb25lbnQgdmFyaWFibGVzXG4gKiB3aGljaCBicmVha3MgdHJlZXNoYWtpbmcuXG4gKiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyB3b3VsZCBiZSBnZW5lcmF0ZWQ6XG4gKiBsZXQgSW9uU2VnbWVudCA9IElvblNlZ21lbnRfMSA9IGNsYXNzIElvblNlZ21lbnQgZXh0ZW5kcyBWYWx1ZUFjY2Vzc29yIHtcbiAqIEluc3RlYWQsIHdlIHdhbnQgb25seSB3YW50IHRoZSBjbGFzcyBnZW5lcmF0ZWQ6XG4gKiBjbGFzcyBJb25TZWdtZW50IGV4dGVuZHMgVmFsdWVBY2Nlc3NvciB7XG4gKi9cbmltcG9ydCB7IHByb3h5SW5wdXRzLCBwcm94eU91dHB1dHMgfSBmcm9tICcuL2FuZ3VsYXItY29tcG9uZW50LWxpYi91dGlscyc7XG5cbmNvbnN0IFNFR01FTlRfSU5QVVRTID0gWydjb2xvcicsICdkaXNhYmxlZCcsICdtb2RlJywgJ3Njcm9sbGFibGUnLCAnc2VsZWN0T25Gb2N1cycsICdzd2lwZUdlc3R1cmUnLCAndmFsdWUnXTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnaW9uLXNlZ21lbnQnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9uby1pbnB1dHMtbWV0YWRhdGEtcHJvcGVydHlcbiAgaW5wdXRzOiBTRUdNRU5UX0lOUFVUUyxcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICB1c2VFeGlzdGluZzogSW9uU2VnbWVudCxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG4gIHN0YW5kYWxvbmU6IHRydWUsXG59KVxuZXhwb3J0IGNsYXNzIElvblNlZ21lbnQgZXh0ZW5kcyBWYWx1ZUFjY2Vzc29yIGltcGxlbWVudHMgT25Jbml0IHtcbiAgcHJvdGVjdGVkIGVsOiBIVE1MRWxlbWVudDtcbiAgY29uc3RydWN0b3IoYzogQ2hhbmdlRGV0ZWN0b3JSZWYsIHI6IEVsZW1lbnRSZWYsIHByb3RlY3RlZCB6OiBOZ1pvbmUsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHN1cGVyKGluamVjdG9yLCByKTtcbiAgICBkZWZpbmVDdXN0b21FbGVtZW50KCk7XG4gICAgYy5kZXRhY2goKTtcbiAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIHByb3h5T3V0cHV0cyh0aGlzLCB0aGlzLmVsLCBbJ2lvbkNoYW5nZSddKTtcbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIC8qKlxuICAgICAqIERhdGEtYm91bmQgaW5wdXQgcHJvcGVydGllcyBhcmUgc2V0XG4gICAgICogYnkgQW5ndWxhciBhZnRlciB0aGUgY29uc3RydWN0b3IsIHNvXG4gICAgICogd2UgbmVlZCB0byBydW4gdGhlIHByb3h5IGluIG5nT25Jbml0LlxuICAgICAqL1xuICAgIHByb3h5SW5wdXRzKElvblNlZ21lbnQsIFNFR01FTlRfSU5QVVRTKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2lvbkNoYW5nZScsIFsnJGV2ZW50LnRhcmdldCddKVxuICBoYW5kbGVJb25DaGFuZ2UoZWw6IEhUTUxJb25TZWdtZW50RWxlbWVudCk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UoZWwsIGVsLnZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgSW9uU2VnbWVudCBleHRlbmRzIENvbXBvbmVudHMuSW9uU2VnbWVudCB7XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIHZhbHVlIHByb3BlcnR5IGhhcyBjaGFuZ2VkIGFuZCBhbnlcbmRyYWdnaW5nIHBvaW50ZXIgaGFzIGJlZW4gcmVsZWFzZWQgZnJvbSBgaW9uLXNlZ21lbnRgLlxuICAgKi9cbiAgaW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Q3VzdG9tRXZlbnQ8U2VnbWVudENoYW5nZUV2ZW50RGV0YWlsPj47XG59XG4iXX0=