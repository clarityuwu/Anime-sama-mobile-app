import { ChangeDetectionStrategy, Component, HostListener, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { ValueAccessor } from '@ionic/angular/common';
import { defineCustomElement } from '@ionic/core/components/ion-select.js';
/**
 * Value accessor components should not use ProxyCmp
 * and should call defineCustomElement and proxyInputs
 * manually instead. Using both the @ProxyCmp and @Component
 * decorators and useExisting (where useExisting refers to the
 * class) causes ng-packagr to output multiple component variables
 * which breaks treeshaking.
 * For example, the following would be generated:
 * let IonSelect = IonSelect_1 = class IonSelect extends ValueAccessor {
 * Instead, we want only want the class generated:
 * class IonSelect extends ValueAccessor {
 */
import { proxyInputs, proxyMethods, proxyOutputs } from './angular-component-lib/utils';
import * as i0 from "@angular/core";
const SELECT_INPUTS = [
    'cancelText',
    'color',
    'compareWith',
    'disabled',
    'expandedIcon',
    'fill',
    'interface',
    'interfaceOptions',
    'justify',
    'label',
    'labelPlacement',
    'legacy',
    'mode',
    'multiple',
    'name',
    'okText',
    'placeholder',
    'selectedText',
    'shape',
    'toggleIcon',
    'value',
];
const SELECT_METHODS = ['open'];
export class IonSelect extends ValueAccessor {
    constructor(c, r, z, injector) {
        super(injector, r);
        this.z = z;
        defineCustomElement();
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionCancel', 'ionDismiss', 'ionFocus', 'ionBlur']);
    }
    ngOnInit() {
        /**
         * Data-bound input properties are set
         * by Angular after the constructor, so
         * we need to run the proxy in ngOnInit.
         */
        proxyInputs(IonSelect, SELECT_INPUTS);
        proxyMethods(IonSelect, SELECT_METHODS);
    }
    handleIonChange(el) {
        this.handleValueChange(el, el.value);
    }
}
/** @nocollapse */ IonSelect.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IonSelect, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ IonSelect.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: IonSelect, isStandalone: true, selector: "ion-select", inputs: { cancelText: "cancelText", color: "color", compareWith: "compareWith", disabled: "disabled", expandedIcon: "expandedIcon", fill: "fill", interface: "interface", interfaceOptions: "interfaceOptions", justify: "justify", label: "label", labelPlacement: "labelPlacement", legacy: "legacy", mode: "mode", multiple: "multiple", name: "name", okText: "okText", placeholder: "placeholder", selectedText: "selectedText", shape: "shape", toggleIcon: "toggleIcon", value: "value" }, host: { listeners: { "ionChange": "handleIonChange($event.target)" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: IonSelect,
            multi: true,
        },
    ], usesInheritance: true, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IonSelect, decorators: [{
            type: Component,
            args: [{
                    selector: 'ion-select',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
                    inputs: SELECT_INPUTS,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IonSelect,
                            multi: true,
                        },
                    ],
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Injector }]; }, propDecorators: { handleIonChange: [{
                type: HostListener,
                args: ['ionChange', ['$event.target']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3RhbmRhbG9uZS9zcmMvZGlyZWN0aXZlcy9zZWxlY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUV2QixTQUFTLEVBR1QsWUFBWSxHQUdiLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUV0RCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUUzRTs7Ozs7Ozs7Ozs7R0FXRztBQUNILE9BQU8sRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxNQUFNLCtCQUErQixDQUFDOztBQUV4RixNQUFNLGFBQWEsR0FBRztJQUNwQixZQUFZO0lBQ1osT0FBTztJQUNQLGFBQWE7SUFDYixVQUFVO0lBQ1YsY0FBYztJQUNkLE1BQU07SUFDTixXQUFXO0lBQ1gsa0JBQWtCO0lBQ2xCLFNBQVM7SUFDVCxPQUFPO0lBQ1AsZ0JBQWdCO0lBQ2hCLFFBQVE7SUFDUixNQUFNO0lBQ04sVUFBVTtJQUNWLE1BQU07SUFDTixRQUFRO0lBQ1IsYUFBYTtJQUNiLGNBQWM7SUFDZCxPQUFPO0lBQ1AsWUFBWTtJQUNaLE9BQU87Q0FDUixDQUFDO0FBRUYsTUFBTSxjQUFjLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQWlCaEMsTUFBTSxPQUFPLFNBQVUsU0FBUSxhQUFhO0lBRTFDLFlBQVksQ0FBb0IsRUFBRSxDQUFhLEVBQVksQ0FBUyxFQUFFLFFBQWtCO1FBQ3RGLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFEc0MsTUFBQyxHQUFELENBQUMsQ0FBUTtRQUVsRSxtQkFBbUIsRUFBRSxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNYLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLGFBQWEsQ0FBQztRQUMxQixZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUMvRixDQUFDO0lBRUQsUUFBUTtRQUNOOzs7O1dBSUc7UUFDSCxXQUFXLENBQUMsU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ3RDLFlBQVksQ0FBQyxTQUFTLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUdELGVBQWUsQ0FBQyxFQUF3QjtRQUN0QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QyxDQUFDOzswSEF2QlUsU0FBUzs4R0FBVCxTQUFTLG1tQkFUVDtRQUNUO1lBQ0UsT0FBTyxFQUFFLGlCQUFpQjtZQUMxQixXQUFXLEVBQUUsU0FBUztZQUN0QixLQUFLLEVBQUUsSUFBSTtTQUNaO0tBQ0YsaURBVFMsMkJBQTJCOzRGQVkxQixTQUFTO2tCQWZyQixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxZQUFZO29CQUN0QixlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsUUFBUSxFQUFFLDJCQUEyQjtvQkFDckMsdUVBQXVFO29CQUN2RSxNQUFNLEVBQUUsYUFBYTtvQkFDckIsU0FBUyxFQUFFO3dCQUNUOzRCQUNFLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsV0FBVzs0QkFDdEIsS0FBSyxFQUFFLElBQUk7eUJBQ1o7cUJBQ0Y7b0JBQ0QsVUFBVSxFQUFFLElBQUk7aUJBQ2pCOzZLQXNCQyxlQUFlO3NCQURkLFlBQVk7dUJBQUMsV0FBVyxFQUFFLENBQUMsZUFBZSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdExpc3RlbmVyLFxuICBJbmplY3RvcixcbiAgTmdab25lLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB0eXBlIHsgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAaW9uaWMvYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHR5cGUgeyBTZWxlY3RDaGFuZ2VFdmVudERldGFpbCwgQ29tcG9uZW50cyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNlbGVjdC5qcyc7XG5cbi8qKlxuICogVmFsdWUgYWNjZXNzb3IgY29tcG9uZW50cyBzaG91bGQgbm90IHVzZSBQcm94eUNtcFxuICogYW5kIHNob3VsZCBjYWxsIGRlZmluZUN1c3RvbUVsZW1lbnQgYW5kIHByb3h5SW5wdXRzXG4gKiBtYW51YWxseSBpbnN0ZWFkLiBVc2luZyBib3RoIHRoZSBAUHJveHlDbXAgYW5kIEBDb21wb25lbnRcbiAqIGRlY29yYXRvcnMgYW5kIHVzZUV4aXN0aW5nICh3aGVyZSB1c2VFeGlzdGluZyByZWZlcnMgdG8gdGhlXG4gKiBjbGFzcykgY2F1c2VzIG5nLXBhY2thZ3IgdG8gb3V0cHV0IG11bHRpcGxlIGNvbXBvbmVudCB2YXJpYWJsZXNcbiAqIHdoaWNoIGJyZWFrcyB0cmVlc2hha2luZy5cbiAqIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIHdvdWxkIGJlIGdlbmVyYXRlZDpcbiAqIGxldCBJb25TZWxlY3QgPSBJb25TZWxlY3RfMSA9IGNsYXNzIElvblNlbGVjdCBleHRlbmRzIFZhbHVlQWNjZXNzb3Ige1xuICogSW5zdGVhZCwgd2Ugd2FudCBvbmx5IHdhbnQgdGhlIGNsYXNzIGdlbmVyYXRlZDpcbiAqIGNsYXNzIElvblNlbGVjdCBleHRlbmRzIFZhbHVlQWNjZXNzb3Ige1xuICovXG5pbXBvcnQgeyBwcm94eUlucHV0cywgcHJveHlNZXRob2RzLCBwcm94eU91dHB1dHMgfSBmcm9tICcuL2FuZ3VsYXItY29tcG9uZW50LWxpYi91dGlscyc7XG5cbmNvbnN0IFNFTEVDVF9JTlBVVFMgPSBbXG4gICdjYW5jZWxUZXh0JyxcbiAgJ2NvbG9yJyxcbiAgJ2NvbXBhcmVXaXRoJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2V4cGFuZGVkSWNvbicsXG4gICdmaWxsJyxcbiAgJ2ludGVyZmFjZScsXG4gICdpbnRlcmZhY2VPcHRpb25zJyxcbiAgJ2p1c3RpZnknLFxuICAnbGFiZWwnLFxuICAnbGFiZWxQbGFjZW1lbnQnLFxuICAnbGVnYWN5JyxcbiAgJ21vZGUnLFxuICAnbXVsdGlwbGUnLFxuICAnbmFtZScsXG4gICdva1RleHQnLFxuICAncGxhY2Vob2xkZXInLFxuICAnc2VsZWN0ZWRUZXh0JyxcbiAgJ3NoYXBlJyxcbiAgJ3RvZ2dsZUljb24nLFxuICAndmFsdWUnLFxuXTtcblxuY29uc3QgU0VMRUNUX01FVEhPRFMgPSBbJ29wZW4nXTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnaW9uLXNlbGVjdCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L25vLWlucHV0cy1tZXRhZGF0YS1wcm9wZXJ0eVxuICBpbnB1dHM6IFNFTEVDVF9JTlBVVFMsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgdXNlRXhpc3Rpbmc6IElvblNlbGVjdCxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG4gIHN0YW5kYWxvbmU6IHRydWUsXG59KVxuZXhwb3J0IGNsYXNzIElvblNlbGVjdCBleHRlbmRzIFZhbHVlQWNjZXNzb3IgaW1wbGVtZW50cyBPbkluaXQge1xuICBwcm90ZWN0ZWQgZWw6IEhUTUxFbGVtZW50O1xuICBjb25zdHJ1Y3RvcihjOiBDaGFuZ2VEZXRlY3RvclJlZiwgcjogRWxlbWVudFJlZiwgcHJvdGVjdGVkIHo6IE5nWm9uZSwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgc3VwZXIoaW5qZWN0b3IsIHIpO1xuICAgIGRlZmluZUN1c3RvbUVsZW1lbnQoKTtcbiAgICBjLmRldGFjaCgpO1xuICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG4gICAgcHJveHlPdXRwdXRzKHRoaXMsIHRoaXMuZWwsIFsnaW9uQ2hhbmdlJywgJ2lvbkNhbmNlbCcsICdpb25EaXNtaXNzJywgJ2lvbkZvY3VzJywgJ2lvbkJsdXInXSk7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAvKipcbiAgICAgKiBEYXRhLWJvdW5kIGlucHV0IHByb3BlcnRpZXMgYXJlIHNldFxuICAgICAqIGJ5IEFuZ3VsYXIgYWZ0ZXIgdGhlIGNvbnN0cnVjdG9yLCBzb1xuICAgICAqIHdlIG5lZWQgdG8gcnVuIHRoZSBwcm94eSBpbiBuZ09uSW5pdC5cbiAgICAgKi9cbiAgICBwcm94eUlucHV0cyhJb25TZWxlY3QsIFNFTEVDVF9JTlBVVFMpO1xuICAgIHByb3h5TWV0aG9kcyhJb25TZWxlY3QsIFNFTEVDVF9NRVRIT0RTKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2lvbkNoYW5nZScsIFsnJGV2ZW50LnRhcmdldCddKVxuICBoYW5kbGVJb25DaGFuZ2UoZWw6IEhUTUxJb25TZWxlY3RFbGVtZW50KTogdm9pZCB7XG4gICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZShlbCwgZWwudmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBJb25TZWxlY3QgZXh0ZW5kcyBDb21wb25lbnRzLklvblNlbGVjdCB7XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgKi9cbiAgaW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Q3VzdG9tRXZlbnQ8U2VsZWN0Q2hhbmdlRXZlbnREZXRhaWw+PjtcbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGNhbmNlbGxlZC5cbiAgICovXG4gIGlvbkNhbmNlbDogRXZlbnRFbWl0dGVyPEN1c3RvbUV2ZW50PHZvaWQ+PjtcbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyBkaXNtaXNzZWQuXG4gICAqL1xuICBpb25EaXNtaXNzOiBFdmVudEVtaXR0ZXI8Q3VzdG9tRXZlbnQ8dm9pZD4+O1xuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgaGFzIGZvY3VzLlxuICAgKi9cbiAgaW9uRm9jdXM6IEV2ZW50RW1pdHRlcjxDdXN0b21FdmVudDx2b2lkPj47XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBsb3NlcyBmb2N1cy5cbiAgICovXG4gIGlvbkJsdXI6IEV2ZW50RW1pdHRlcjxDdXN0b21FdmVudDx2b2lkPj47XG59XG4iXX0=