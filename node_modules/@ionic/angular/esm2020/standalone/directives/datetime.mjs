import { ChangeDetectionStrategy, Component, HostListener, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { ValueAccessor } from '@ionic/angular/common';
import { defineCustomElement } from '@ionic/core/components/ion-datetime.js';
/**
 * Value accessor components should not use ProxyCmp
 * and should call defineCustomElement and proxyInputs
 * manually instead. Using both the @ProxyCmp and @Component
 * decorators and useExisting (where useExisting refers to the
 * class) causes ng-packagr to output multiple component variables
 * which breaks treeshaking.
 * For example, the following would be generated:
 * let IonDatetime = IonDatetime_1 = class IonDatetime extends ValueAccessor {
 * Instead, we want only want the class generated:
 * class IonDatetime extends ValueAccessor {
 */
import { proxyInputs, proxyMethods, proxyOutputs } from './angular-component-lib/utils';
import * as i0 from "@angular/core";
const DATETIME_INPUTS = [
    'cancelText',
    'clearText',
    'color',
    'dayValues',
    'disabled',
    'doneText',
    'firstDayOfWeek',
    'highlightedDates',
    'hourCycle',
    'hourValues',
    'isDateEnabled',
    'locale',
    'max',
    'min',
    'minuteValues',
    'mode',
    'monthValues',
    'multiple',
    'name',
    'preferWheel',
    'presentation',
    'readonly',
    'showClearButton',
    'showDefaultButtons',
    'showDefaultTimeLabel',
    'showDefaultTitle',
    'size',
    'titleSelectedDatesFormatter',
    'value',
    'yearValues',
];
const DATETIME_METHODS = ['confirm', 'reset', 'cancel'];
export class IonDatetime extends ValueAccessor {
    constructor(c, r, z, injector) {
        super(injector, r);
        this.z = z;
        defineCustomElement();
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionCancel', 'ionChange', 'ionFocus', 'ionBlur']);
    }
    ngOnInit() {
        /**
         * Data-bound input properties are set
         * by Angular after the constructor, so
         * we need to run the proxy in ngOnInit.
         */
        proxyInputs(IonDatetime, DATETIME_INPUTS);
        proxyMethods(IonDatetime, DATETIME_METHODS);
    }
    handleIonChange(el) {
        this.handleValueChange(el, el.value);
    }
}
/** @nocollapse */ IonDatetime.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IonDatetime, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ IonDatetime.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: IonDatetime, isStandalone: true, selector: "ion-datetime", inputs: { cancelText: "cancelText", clearText: "clearText", color: "color", dayValues: "dayValues", disabled: "disabled", doneText: "doneText", firstDayOfWeek: "firstDayOfWeek", highlightedDates: "highlightedDates", hourCycle: "hourCycle", hourValues: "hourValues", isDateEnabled: "isDateEnabled", locale: "locale", max: "max", min: "min", minuteValues: "minuteValues", mode: "mode", monthValues: "monthValues", multiple: "multiple", name: "name", preferWheel: "preferWheel", presentation: "presentation", readonly: "readonly", showClearButton: "showClearButton", showDefaultButtons: "showDefaultButtons", showDefaultTimeLabel: "showDefaultTimeLabel", showDefaultTitle: "showDefaultTitle", size: "size", titleSelectedDatesFormatter: "titleSelectedDatesFormatter", value: "value", yearValues: "yearValues" }, host: { listeners: { "ionChange": "handleIonChange($event.target)" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: IonDatetime,
            multi: true,
        },
    ], usesInheritance: true, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IonDatetime, decorators: [{
            type: Component,
            args: [{
                    selector: 'ion-datetime',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
                    inputs: DATETIME_INPUTS,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IonDatetime,
                            multi: true,
                        },
                    ],
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Injector }]; }, propDecorators: { handleIonChange: [{
                type: HostListener,
                args: ['ionChange', ['$event.target']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXRpbWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zdGFuZGFsb25lL3NyYy9kaXJlY3RpdmVzL2RhdGV0aW1lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUdULFlBQVksR0FHYixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFdEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFFN0U7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxPQUFPLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQzs7QUFFeEYsTUFBTSxlQUFlLEdBQUc7SUFDdEIsWUFBWTtJQUNaLFdBQVc7SUFDWCxPQUFPO0lBQ1AsV0FBVztJQUNYLFVBQVU7SUFDVixVQUFVO0lBQ1YsZ0JBQWdCO0lBQ2hCLGtCQUFrQjtJQUNsQixXQUFXO0lBQ1gsWUFBWTtJQUNaLGVBQWU7SUFDZixRQUFRO0lBQ1IsS0FBSztJQUNMLEtBQUs7SUFDTCxjQUFjO0lBQ2QsTUFBTTtJQUNOLGFBQWE7SUFDYixVQUFVO0lBQ1YsTUFBTTtJQUNOLGFBQWE7SUFDYixjQUFjO0lBQ2QsVUFBVTtJQUNWLGlCQUFpQjtJQUNqQixvQkFBb0I7SUFDcEIsc0JBQXNCO0lBQ3RCLGtCQUFrQjtJQUNsQixNQUFNO0lBQ04sNkJBQTZCO0lBQzdCLE9BQU87SUFDUCxZQUFZO0NBQ2IsQ0FBQztBQUVGLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBaUJ4RCxNQUFNLE9BQU8sV0FBWSxTQUFRLGFBQWE7SUFFNUMsWUFBWSxDQUFvQixFQUFFLENBQWEsRUFBWSxDQUFTLEVBQUUsUUFBa0I7UUFDdEYsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztRQURzQyxNQUFDLEdBQUQsQ0FBQyxDQUFRO1FBRWxFLG1CQUFtQixFQUFFLENBQUM7UUFDdEIsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ1gsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsYUFBYSxDQUFDO1FBQzFCLFlBQVksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDakYsQ0FBQztJQUVELFFBQVE7UUFDTjs7OztXQUlHO1FBQ0gsV0FBVyxDQUFDLFdBQVcsRUFBRSxlQUFlLENBQUMsQ0FBQztRQUMxQyxZQUFZLENBQUMsV0FBVyxFQUFFLGdCQUFnQixDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUdELGVBQWUsQ0FBQyxFQUEwQjtRQUN4QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QyxDQUFDOzs0SEF2QlUsV0FBVztnSEFBWCxXQUFXLDI2QkFUWDtRQUNUO1lBQ0UsT0FBTyxFQUFFLGlCQUFpQjtZQUMxQixXQUFXLEVBQUUsV0FBVztZQUN4QixLQUFLLEVBQUUsSUFBSTtTQUNaO0tBQ0YsaURBVFMsMkJBQTJCOzRGQVkxQixXQUFXO2tCQWZ2QixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxjQUFjO29CQUN4QixlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsUUFBUSxFQUFFLDJCQUEyQjtvQkFDckMsdUVBQXVFO29CQUN2RSxNQUFNLEVBQUUsZUFBZTtvQkFDdkIsU0FBUyxFQUFFO3dCQUNUOzRCQUNFLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsYUFBYTs0QkFDeEIsS0FBSyxFQUFFLElBQUk7eUJBQ1o7cUJBQ0Y7b0JBQ0QsVUFBVSxFQUFFLElBQUk7aUJBQ2pCOzZLQXNCQyxlQUFlO3NCQURkLFlBQVk7dUJBQUMsV0FBVyxFQUFFLENBQUMsZUFBZSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdExpc3RlbmVyLFxuICBJbmplY3RvcixcbiAgTmdab25lLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB0eXBlIHsgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAaW9uaWMvYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHR5cGUgeyBEYXRldGltZUNoYW5nZUV2ZW50RGV0YWlsLCBDb21wb25lbnRzIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tZGF0ZXRpbWUuanMnO1xuXG4vKipcbiAqIFZhbHVlIGFjY2Vzc29yIGNvbXBvbmVudHMgc2hvdWxkIG5vdCB1c2UgUHJveHlDbXBcbiAqIGFuZCBzaG91bGQgY2FsbCBkZWZpbmVDdXN0b21FbGVtZW50IGFuZCBwcm94eUlucHV0c1xuICogbWFudWFsbHkgaW5zdGVhZC4gVXNpbmcgYm90aCB0aGUgQFByb3h5Q21wIGFuZCBAQ29tcG9uZW50XG4gKiBkZWNvcmF0b3JzIGFuZCB1c2VFeGlzdGluZyAod2hlcmUgdXNlRXhpc3RpbmcgcmVmZXJzIHRvIHRoZVxuICogY2xhc3MpIGNhdXNlcyBuZy1wYWNrYWdyIHRvIG91dHB1dCBtdWx0aXBsZSBjb21wb25lbnQgdmFyaWFibGVzXG4gKiB3aGljaCBicmVha3MgdHJlZXNoYWtpbmcuXG4gKiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyB3b3VsZCBiZSBnZW5lcmF0ZWQ6XG4gKiBsZXQgSW9uRGF0ZXRpbWUgPSBJb25EYXRldGltZV8xID0gY2xhc3MgSW9uRGF0ZXRpbWUgZXh0ZW5kcyBWYWx1ZUFjY2Vzc29yIHtcbiAqIEluc3RlYWQsIHdlIHdhbnQgb25seSB3YW50IHRoZSBjbGFzcyBnZW5lcmF0ZWQ6XG4gKiBjbGFzcyBJb25EYXRldGltZSBleHRlbmRzIFZhbHVlQWNjZXNzb3Ige1xuICovXG5pbXBvcnQgeyBwcm94eUlucHV0cywgcHJveHlNZXRob2RzLCBwcm94eU91dHB1dHMgfSBmcm9tICcuL2FuZ3VsYXItY29tcG9uZW50LWxpYi91dGlscyc7XG5cbmNvbnN0IERBVEVUSU1FX0lOUFVUUyA9IFtcbiAgJ2NhbmNlbFRleHQnLFxuICAnY2xlYXJUZXh0JyxcbiAgJ2NvbG9yJyxcbiAgJ2RheVZhbHVlcycsXG4gICdkaXNhYmxlZCcsXG4gICdkb25lVGV4dCcsXG4gICdmaXJzdERheU9mV2VlaycsXG4gICdoaWdobGlnaHRlZERhdGVzJyxcbiAgJ2hvdXJDeWNsZScsXG4gICdob3VyVmFsdWVzJyxcbiAgJ2lzRGF0ZUVuYWJsZWQnLFxuICAnbG9jYWxlJyxcbiAgJ21heCcsXG4gICdtaW4nLFxuICAnbWludXRlVmFsdWVzJyxcbiAgJ21vZGUnLFxuICAnbW9udGhWYWx1ZXMnLFxuICAnbXVsdGlwbGUnLFxuICAnbmFtZScsXG4gICdwcmVmZXJXaGVlbCcsXG4gICdwcmVzZW50YXRpb24nLFxuICAncmVhZG9ubHknLFxuICAnc2hvd0NsZWFyQnV0dG9uJyxcbiAgJ3Nob3dEZWZhdWx0QnV0dG9ucycsXG4gICdzaG93RGVmYXVsdFRpbWVMYWJlbCcsXG4gICdzaG93RGVmYXVsdFRpdGxlJyxcbiAgJ3NpemUnLFxuICAndGl0bGVTZWxlY3RlZERhdGVzRm9ybWF0dGVyJyxcbiAgJ3ZhbHVlJyxcbiAgJ3llYXJWYWx1ZXMnLFxuXTtcblxuY29uc3QgREFURVRJTUVfTUVUSE9EUyA9IFsnY29uZmlybScsICdyZXNldCcsICdjYW5jZWwnXTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnaW9uLWRhdGV0aW1lJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvbm8taW5wdXRzLW1ldGFkYXRhLXByb3BlcnR5XG4gIGlucHV0czogREFURVRJTUVfSU5QVVRTLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIHVzZUV4aXN0aW5nOiBJb25EYXRldGltZSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG4gIHN0YW5kYWxvbmU6IHRydWUsXG59KVxuZXhwb3J0IGNsYXNzIElvbkRhdGV0aW1lIGV4dGVuZHMgVmFsdWVBY2Nlc3NvciBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIHByb3RlY3RlZCBlbDogSFRNTEVsZW1lbnQ7XG4gIGNvbnN0cnVjdG9yKGM6IENoYW5nZURldGVjdG9yUmVmLCByOiBFbGVtZW50UmVmLCBwcm90ZWN0ZWQgejogTmdab25lLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICBzdXBlcihpbmplY3Rvciwgcik7XG4gICAgZGVmaW5lQ3VzdG9tRWxlbWVudCgpO1xuICAgIGMuZGV0YWNoKCk7XG4gICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICBwcm94eU91dHB1dHModGhpcywgdGhpcy5lbCwgWydpb25DYW5jZWwnLCAnaW9uQ2hhbmdlJywgJ2lvbkZvY3VzJywgJ2lvbkJsdXInXSk7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAvKipcbiAgICAgKiBEYXRhLWJvdW5kIGlucHV0IHByb3BlcnRpZXMgYXJlIHNldFxuICAgICAqIGJ5IEFuZ3VsYXIgYWZ0ZXIgdGhlIGNvbnN0cnVjdG9yLCBzb1xuICAgICAqIHdlIG5lZWQgdG8gcnVuIHRoZSBwcm94eSBpbiBuZ09uSW5pdC5cbiAgICAgKi9cbiAgICBwcm94eUlucHV0cyhJb25EYXRldGltZSwgREFURVRJTUVfSU5QVVRTKTtcbiAgICBwcm94eU1ldGhvZHMoSW9uRGF0ZXRpbWUsIERBVEVUSU1FX01FVEhPRFMpO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignaW9uQ2hhbmdlJywgWyckZXZlbnQudGFyZ2V0J10pXG4gIGhhbmRsZUlvbkNoYW5nZShlbDogSFRNTElvbkRhdGV0aW1lRWxlbWVudCk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UoZWwsIGVsLnZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgSW9uRGF0ZXRpbWUgZXh0ZW5kcyBDb21wb25lbnRzLklvbkRhdGV0aW1lIHtcbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgZGF0ZXRpbWUgc2VsZWN0aW9uIHdhcyBjYW5jZWxsZWQuXG4gICAqL1xuICBpb25DYW5jZWw6IEV2ZW50RW1pdHRlcjxDdXN0b21FdmVudDx2b2lkPj47XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIHZhbHVlIChzZWxlY3RlZCBkYXRlKSBoYXMgY2hhbmdlZC5cbiAgICovXG4gIGlvbkNoYW5nZTogRXZlbnRFbWl0dGVyPEN1c3RvbUV2ZW50PERhdGV0aW1lQ2hhbmdlRXZlbnREZXRhaWw+PjtcbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgZGF0ZXRpbWUgaGFzIGZvY3VzLlxuICAgKi9cbiAgaW9uRm9jdXM6IEV2ZW50RW1pdHRlcjxDdXN0b21FdmVudDx2b2lkPj47XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIGRhdGV0aW1lIGxvc2VzIGZvY3VzLlxuICAgKi9cbiAgaW9uQmx1cjogRXZlbnRFbWl0dGVyPEN1c3RvbUV2ZW50PHZvaWQ+Pjtcbn1cbiJdfQ==