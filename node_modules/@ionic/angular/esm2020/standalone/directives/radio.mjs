import { ChangeDetectionStrategy, Component, HostListener, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { ValueAccessor } from '@ionic/angular/common';
import { defineCustomElement } from '@ionic/core/components/ion-radio.js';
/**
 * Value accessor components should not use ProxyCmp
 * and should call defineCustomElement and proxyInputs
 * manually instead. Using both the @ProxyCmp and @Component
 * decorators and useExisting (where useExisting refers to the
 * class) causes ng-packagr to output multiple component variables
 * which breaks treeshaking.
 * For example, the following would be generated:
 * let IonRadio = IonRadio_1 = class IonRadio extends ValueAccessor {
 * Instead, we want only want the class generated:
 * class IonRadio extends ValueAccessor {
 */
import { proxyInputs, proxyOutputs } from './angular-component-lib/utils';
import * as i0 from "@angular/core";
const RADIO_INPUTS = ['color', 'disabled', 'justify', 'labelPlacement', 'legacy', 'mode', 'name', 'value'];
export class IonRadio extends ValueAccessor {
    constructor(c, r, z, injector) {
        super(injector, r);
        this.z = z;
        defineCustomElement();
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);
    }
    ngOnInit() {
        /**
         * Data-bound input properties are set
         * by Angular after the constructor, so
         * we need to run the proxy in ngOnInit.
         */
        proxyInputs(IonRadio, RADIO_INPUTS);
    }
    handleIonSelect(el) {
        /**
         * The `el` type is any to access the `checked` state property
         * that is not exposed on the type interface.
         */
        this.handleValueChange(el, el.checked);
    }
}
/** @nocollapse */ IonRadio.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IonRadio, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ IonRadio.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: IonRadio, isStandalone: true, selector: "ion-radio", inputs: { color: "color", disabled: "disabled", justify: "justify", labelPlacement: "labelPlacement", legacy: "legacy", mode: "mode", name: "name", value: "value" }, host: { listeners: { "ionSelect": "handleIonSelect($event.target)" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: IonRadio,
            multi: true,
        },
    ], usesInheritance: true, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IonRadio, decorators: [{
            type: Component,
            args: [{
                    selector: 'ion-radio',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
                    inputs: RADIO_INPUTS,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IonRadio,
                            multi: true,
                        },
                    ],
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Injector }]; }, propDecorators: { handleIonSelect: [{
                type: HostListener,
                args: ['ionSelect', ['$event.target']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFkaW8uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zdGFuZGFsb25lL3NyYy9kaXJlY3RpdmVzL3JhZGlvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUdULFlBQVksR0FHYixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFdEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFFMUU7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxPQUFPLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxNQUFNLCtCQUErQixDQUFDOztBQUUxRSxNQUFNLFlBQVksR0FBRyxDQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBaUIzRyxNQUFNLE9BQU8sUUFBUyxTQUFRLGFBQWE7SUFFekMsWUFBWSxDQUFvQixFQUFFLENBQWEsRUFBWSxDQUFTLEVBQUUsUUFBa0I7UUFDdEYsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztRQURzQyxNQUFDLEdBQUQsQ0FBQyxDQUFRO1FBRWxFLG1CQUFtQixFQUFFLENBQUM7UUFDdEIsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ1gsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsYUFBYSxDQUFDO1FBQzFCLFlBQVksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCxRQUFRO1FBQ047Ozs7V0FJRztRQUNILFdBQVcsQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUdELGVBQWUsQ0FBQyxFQUFPO1FBQ3JCOzs7V0FHRztRQUNILElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3pDLENBQUM7O3lIQTFCVSxRQUFROzZHQUFSLFFBQVEsc1NBVFI7UUFDVDtZQUNFLE9BQU8sRUFBRSxpQkFBaUI7WUFDMUIsV0FBVyxFQUFFLFFBQVE7WUFDckIsS0FBSyxFQUFFLElBQUk7U0FDWjtLQUNGLGlEQVRTLDJCQUEyQjs0RkFZMUIsUUFBUTtrQkFmcEIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsV0FBVztvQkFDckIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLFFBQVEsRUFBRSwyQkFBMkI7b0JBQ3JDLHVFQUF1RTtvQkFDdkUsTUFBTSxFQUFFLFlBQVk7b0JBQ3BCLFNBQVMsRUFBRTt3QkFDVDs0QkFDRSxPQUFPLEVBQUUsaUJBQWlCOzRCQUMxQixXQUFXLFVBQVU7NEJBQ3JCLEtBQUssRUFBRSxJQUFJO3lCQUNaO3FCQUNGO29CQUNELFVBQVUsRUFBRSxJQUFJO2lCQUNqQjs2S0FxQkMsZUFBZTtzQkFEZCxZQUFZO3VCQUFDLFdBQVcsRUFBRSxDQUFDLGVBQWUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5qZWN0b3IsXG4gIE5nWm9uZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgdHlwZSB7IE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBWYWx1ZUFjY2Vzc29yIH0gZnJvbSAnQGlvbmljL2FuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50cyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJhZGlvLmpzJztcblxuLyoqXG4gKiBWYWx1ZSBhY2Nlc3NvciBjb21wb25lbnRzIHNob3VsZCBub3QgdXNlIFByb3h5Q21wXG4gKiBhbmQgc2hvdWxkIGNhbGwgZGVmaW5lQ3VzdG9tRWxlbWVudCBhbmQgcHJveHlJbnB1dHNcbiAqIG1hbnVhbGx5IGluc3RlYWQuIFVzaW5nIGJvdGggdGhlIEBQcm94eUNtcCBhbmQgQENvbXBvbmVudFxuICogZGVjb3JhdG9ycyBhbmQgdXNlRXhpc3RpbmcgKHdoZXJlIHVzZUV4aXN0aW5nIHJlZmVycyB0byB0aGVcbiAqIGNsYXNzKSBjYXVzZXMgbmctcGFja2FnciB0byBvdXRwdXQgbXVsdGlwbGUgY29tcG9uZW50IHZhcmlhYmxlc1xuICogd2hpY2ggYnJlYWtzIHRyZWVzaGFraW5nLlxuICogRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgd291bGQgYmUgZ2VuZXJhdGVkOlxuICogbGV0IElvblJhZGlvID0gSW9uUmFkaW9fMSA9IGNsYXNzIElvblJhZGlvIGV4dGVuZHMgVmFsdWVBY2Nlc3NvciB7XG4gKiBJbnN0ZWFkLCB3ZSB3YW50IG9ubHkgd2FudCB0aGUgY2xhc3MgZ2VuZXJhdGVkOlxuICogY2xhc3MgSW9uUmFkaW8gZXh0ZW5kcyBWYWx1ZUFjY2Vzc29yIHtcbiAqL1xuaW1wb3J0IHsgcHJveHlJbnB1dHMsIHByb3h5T3V0cHV0cyB9IGZyb20gJy4vYW5ndWxhci1jb21wb25lbnQtbGliL3V0aWxzJztcblxuY29uc3QgUkFESU9fSU5QVVRTID0gWydjb2xvcicsICdkaXNhYmxlZCcsICdqdXN0aWZ5JywgJ2xhYmVsUGxhY2VtZW50JywgJ2xlZ2FjeScsICdtb2RlJywgJ25hbWUnLCAndmFsdWUnXTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnaW9uLXJhZGlvJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvbm8taW5wdXRzLW1ldGFkYXRhLXByb3BlcnR5XG4gIGlucHV0czogUkFESU9fSU5QVVRTLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIHVzZUV4aXN0aW5nOiBJb25SYWRpbyxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG4gIHN0YW5kYWxvbmU6IHRydWUsXG59KVxuZXhwb3J0IGNsYXNzIElvblJhZGlvIGV4dGVuZHMgVmFsdWVBY2Nlc3NvciBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIHByb3RlY3RlZCBlbDogSFRNTEVsZW1lbnQ7XG4gIGNvbnN0cnVjdG9yKGM6IENoYW5nZURldGVjdG9yUmVmLCByOiBFbGVtZW50UmVmLCBwcm90ZWN0ZWQgejogTmdab25lLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICBzdXBlcihpbmplY3Rvciwgcik7XG4gICAgZGVmaW5lQ3VzdG9tRWxlbWVudCgpO1xuICAgIGMuZGV0YWNoKCk7XG4gICAgdGhpcy5lbCA9IHIubmF0aXZlRWxlbWVudDtcbiAgICBwcm94eU91dHB1dHModGhpcywgdGhpcy5lbCwgWydpb25Gb2N1cycsICdpb25CbHVyJ10pO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgLyoqXG4gICAgICogRGF0YS1ib3VuZCBpbnB1dCBwcm9wZXJ0aWVzIGFyZSBzZXRcbiAgICAgKiBieSBBbmd1bGFyIGFmdGVyIHRoZSBjb25zdHJ1Y3Rvciwgc29cbiAgICAgKiB3ZSBuZWVkIHRvIHJ1biB0aGUgcHJveHkgaW4gbmdPbkluaXQuXG4gICAgICovXG4gICAgcHJveHlJbnB1dHMoSW9uUmFkaW8sIFJBRElPX0lOUFVUUyk7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdpb25TZWxlY3QnLCBbJyRldmVudC50YXJnZXQnXSlcbiAgaGFuZGxlSW9uU2VsZWN0KGVsOiBhbnkpOiB2b2lkIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYGVsYCB0eXBlIGlzIGFueSB0byBhY2Nlc3MgdGhlIGBjaGVja2VkYCBzdGF0ZSBwcm9wZXJ0eVxuICAgICAqIHRoYXQgaXMgbm90IGV4cG9zZWQgb24gdGhlIHR5cGUgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlVmFsdWVDaGFuZ2UoZWwsIGVsLmNoZWNrZWQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBJb25SYWRpbyBleHRlbmRzIENvbXBvbmVudHMuSW9uUmFkaW8ge1xuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIHRoZSByYWRpbyBidXR0b24gaGFzIGZvY3VzLlxuICAgKi9cbiAgaW9uRm9jdXM6IEV2ZW50RW1pdHRlcjxDdXN0b21FdmVudDx2b2lkPj47XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIHJhZGlvIGJ1dHRvbiBsb3NlcyBmb2N1cy5cbiAgICovXG4gIGlvbkJsdXI6IEV2ZW50RW1pdHRlcjxDdXN0b21FdmVudDx2b2lkPj47XG59XG4iXX0=