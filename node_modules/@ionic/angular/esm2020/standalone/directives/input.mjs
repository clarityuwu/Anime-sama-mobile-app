import { ChangeDetectionStrategy, Component, HostListener, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { ValueAccessor } from '@ionic/angular/common';
import { defineCustomElement } from '@ionic/core/components/ion-input.js';
/**
 * Value accessor components should not use ProxyCmp
 * and should call defineCustomElement and proxyInputs
 * manually instead. Using both the @ProxyCmp and @Component
 * decorators and useExisting (where useExisting refers to the
 * class) causes ng-packagr to output multiple component variables
 * which breaks treeshaking.
 * For example, the following would be generated:
 * let IonInput = IonInput_1 = class IonInput extends ValueAccessor {
 * Instead, we want only want the class generated:
 * class IonInput extends ValueAccessor {
 */
import { proxyInputs, proxyMethods, proxyOutputs } from './angular-component-lib/utils';
import * as i0 from "@angular/core";
const INPUT_INPUTS = [
    'accept',
    'autocapitalize',
    'autocomplete',
    'autocorrect',
    'autofocus',
    'clearInput',
    'clearOnEdit',
    'color',
    'counter',
    'counterFormatter',
    'debounce',
    'disabled',
    'enterkeyhint',
    'errorText',
    'fill',
    'helperText',
    'inputmode',
    'label',
    'labelPlacement',
    'legacy',
    'max',
    'maxlength',
    'min',
    'minlength',
    'mode',
    'multiple',
    'name',
    'pattern',
    'placeholder',
    'readonly',
    'required',
    'shape',
    'size',
    'spellcheck',
    'step',
    'type',
    'value',
];
const INPUT_METHODS = ['setFocus', 'getInputElement'];
export class IonInput extends ValueAccessor {
    constructor(c, r, z, injector) {
        super(injector, r);
        this.z = z;
        defineCustomElement();
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionBlur', 'ionFocus']);
    }
    ngOnInit() {
        /**
         * Data-bound input properties are set
         * by Angular after the constructor, so
         * we need to run the proxy in ngOnInit.
         */
        proxyInputs(IonInput, INPUT_INPUTS);
        proxyMethods(IonInput, INPUT_METHODS);
    }
    handleIonInput(el) {
        this.handleValueChange(el, el.value);
    }
    registerOnChange(fn) {
        super.registerOnChange((value) => {
            if (this.type === 'number') {
                /**
                 * If the input type is `number`, we need to convert the value to a number
                 * when the value is not empty. If the value is empty, we want to treat
                 * the value as null.
                 */
                fn(value === '' ? null : parseFloat(value));
            }
            else {
                fn(value);
            }
        });
    }
}
/** @nocollapse */ IonInput.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IonInput, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ IonInput.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: IonInput, isStandalone: true, selector: "ion-input", inputs: { accept: "accept", autocapitalize: "autocapitalize", autocomplete: "autocomplete", autocorrect: "autocorrect", autofocus: "autofocus", clearInput: "clearInput", clearOnEdit: "clearOnEdit", color: "color", counter: "counter", counterFormatter: "counterFormatter", debounce: "debounce", disabled: "disabled", enterkeyhint: "enterkeyhint", errorText: "errorText", fill: "fill", helperText: "helperText", inputmode: "inputmode", label: "label", labelPlacement: "labelPlacement", legacy: "legacy", max: "max", maxlength: "maxlength", min: "min", minlength: "minlength", mode: "mode", multiple: "multiple", name: "name", pattern: "pattern", placeholder: "placeholder", readonly: "readonly", required: "required", shape: "shape", size: "size", spellcheck: "spellcheck", step: "step", type: "type", value: "value" }, host: { listeners: { "ionInput": "handleIonInput($event.target)" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: IonInput,
            multi: true,
        },
    ], usesInheritance: true, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: IonInput, decorators: [{
            type: Component,
            args: [{
                    selector: 'ion-input',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
                    inputs: INPUT_INPUTS,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IonInput,
                            multi: true,
                        },
                    ],
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Injector }]; }, propDecorators: { handleIonInput: [{
                type: HostListener,
                args: ['ionInput', ['$event.target']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zdGFuZGFsb25lL3NyYy9kaXJlY3RpdmVzL2lucHV0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUdULFlBQVksR0FHYixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFNdEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFFMUU7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxPQUFPLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQzs7QUFFeEYsTUFBTSxZQUFZLEdBQUc7SUFDbkIsUUFBUTtJQUNSLGdCQUFnQjtJQUNoQixjQUFjO0lBQ2QsYUFBYTtJQUNiLFdBQVc7SUFDWCxZQUFZO0lBQ1osYUFBYTtJQUNiLE9BQU87SUFDUCxTQUFTO0lBQ1Qsa0JBQWtCO0lBQ2xCLFVBQVU7SUFDVixVQUFVO0lBQ1YsY0FBYztJQUNkLFdBQVc7SUFDWCxNQUFNO0lBQ04sWUFBWTtJQUNaLFdBQVc7SUFDWCxPQUFPO0lBQ1AsZ0JBQWdCO0lBQ2hCLFFBQVE7SUFDUixLQUFLO0lBQ0wsV0FBVztJQUNYLEtBQUs7SUFDTCxXQUFXO0lBQ1gsTUFBTTtJQUNOLFVBQVU7SUFDVixNQUFNO0lBQ04sU0FBUztJQUNULGFBQWE7SUFDYixVQUFVO0lBQ1YsVUFBVTtJQUNWLE9BQU87SUFDUCxNQUFNO0lBQ04sWUFBWTtJQUNaLE1BQU07SUFDTixNQUFNO0lBQ04sT0FBTztDQUNSLENBQUM7QUFFRixNQUFNLGFBQWEsR0FBRyxDQUFDLFVBQVUsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0FBaUJ0RCxNQUFNLE9BQU8sUUFBUyxTQUFRLGFBQWE7SUFFekMsWUFBWSxDQUFvQixFQUFFLENBQWEsRUFBWSxDQUFTLEVBQUUsUUFBa0I7UUFDdEYsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztRQURzQyxNQUFDLEdBQUQsQ0FBQyxDQUFRO1FBRWxFLG1CQUFtQixFQUFFLENBQUM7UUFDdEIsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ1gsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsYUFBYSxDQUFDO1FBQzFCLFlBQVksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLFVBQVUsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFDaEYsQ0FBQztJQUVELFFBQVE7UUFDTjs7OztXQUlHO1FBQ0gsV0FBVyxDQUFDLFFBQVEsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUNwQyxZQUFZLENBQUMsUUFBUSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFHRCxjQUFjLENBQUMsRUFBdUI7UUFDcEMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVELGdCQUFnQixDQUFDLEVBQW9CO1FBQ25DLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEtBQWEsRUFBRSxFQUFFO1lBQ3ZDLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7Z0JBQzFCOzs7O21CQUlHO2dCQUNILEVBQUUsQ0FBQyxLQUFLLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2FBQzdDO2lCQUFNO2dCQUNMLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNYO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDOzt5SEF0Q1UsUUFBUTs2R0FBUixRQUFRLGc3QkFUUjtRQUNUO1lBQ0UsT0FBTyxFQUFFLGlCQUFpQjtZQUMxQixXQUFXLEVBQUUsUUFBUTtZQUNyQixLQUFLLEVBQUUsSUFBSTtTQUNaO0tBQ0YsaURBVFMsMkJBQTJCOzRGQVkxQixRQUFRO2tCQWZwQixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxXQUFXO29CQUNyQixlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsUUFBUSxFQUFFLDJCQUEyQjtvQkFDckMsdUVBQXVFO29CQUN2RSxNQUFNLEVBQUUsWUFBWTtvQkFDcEIsU0FBUyxFQUFFO3dCQUNUOzRCQUNFLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsVUFBVTs0QkFDckIsS0FBSyxFQUFFLElBQUk7eUJBQ1o7cUJBQ0Y7b0JBQ0QsVUFBVSxFQUFFLElBQUk7aUJBQ2pCOzZLQXNCQyxjQUFjO3NCQURiLFlBQVk7dUJBQUMsVUFBVSxFQUFFLENBQUMsZUFBZSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdExpc3RlbmVyLFxuICBJbmplY3RvcixcbiAgTmdab25lLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB0eXBlIHsgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAaW9uaWMvYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHR5cGUge1xuICBJbnB1dElucHV0RXZlbnREZXRhaWwgYXMgSUlvbklucHV0SW5wdXRJbnB1dEV2ZW50RGV0YWlsLFxuICBJbnB1dENoYW5nZUV2ZW50RGV0YWlsIGFzIElJb25JbnB1dElucHV0Q2hhbmdlRXZlbnREZXRhaWwsXG4gIENvbXBvbmVudHMsXG59IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWlucHV0LmpzJztcblxuLyoqXG4gKiBWYWx1ZSBhY2Nlc3NvciBjb21wb25lbnRzIHNob3VsZCBub3QgdXNlIFByb3h5Q21wXG4gKiBhbmQgc2hvdWxkIGNhbGwgZGVmaW5lQ3VzdG9tRWxlbWVudCBhbmQgcHJveHlJbnB1dHNcbiAqIG1hbnVhbGx5IGluc3RlYWQuIFVzaW5nIGJvdGggdGhlIEBQcm94eUNtcCBhbmQgQENvbXBvbmVudFxuICogZGVjb3JhdG9ycyBhbmQgdXNlRXhpc3RpbmcgKHdoZXJlIHVzZUV4aXN0aW5nIHJlZmVycyB0byB0aGVcbiAqIGNsYXNzKSBjYXVzZXMgbmctcGFja2FnciB0byBvdXRwdXQgbXVsdGlwbGUgY29tcG9uZW50IHZhcmlhYmxlc1xuICogd2hpY2ggYnJlYWtzIHRyZWVzaGFraW5nLlxuICogRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgd291bGQgYmUgZ2VuZXJhdGVkOlxuICogbGV0IElvbklucHV0ID0gSW9uSW5wdXRfMSA9IGNsYXNzIElvbklucHV0IGV4dGVuZHMgVmFsdWVBY2Nlc3NvciB7XG4gKiBJbnN0ZWFkLCB3ZSB3YW50IG9ubHkgd2FudCB0aGUgY2xhc3MgZ2VuZXJhdGVkOlxuICogY2xhc3MgSW9uSW5wdXQgZXh0ZW5kcyBWYWx1ZUFjY2Vzc29yIHtcbiAqL1xuaW1wb3J0IHsgcHJveHlJbnB1dHMsIHByb3h5TWV0aG9kcywgcHJveHlPdXRwdXRzIH0gZnJvbSAnLi9hbmd1bGFyLWNvbXBvbmVudC1saWIvdXRpbHMnO1xuXG5jb25zdCBJTlBVVF9JTlBVVFMgPSBbXG4gICdhY2NlcHQnLFxuICAnYXV0b2NhcGl0YWxpemUnLFxuICAnYXV0b2NvbXBsZXRlJyxcbiAgJ2F1dG9jb3JyZWN0JyxcbiAgJ2F1dG9mb2N1cycsXG4gICdjbGVhcklucHV0JyxcbiAgJ2NsZWFyT25FZGl0JyxcbiAgJ2NvbG9yJyxcbiAgJ2NvdW50ZXInLFxuICAnY291bnRlckZvcm1hdHRlcicsXG4gICdkZWJvdW5jZScsXG4gICdkaXNhYmxlZCcsXG4gICdlbnRlcmtleWhpbnQnLFxuICAnZXJyb3JUZXh0JyxcbiAgJ2ZpbGwnLFxuICAnaGVscGVyVGV4dCcsXG4gICdpbnB1dG1vZGUnLFxuICAnbGFiZWwnLFxuICAnbGFiZWxQbGFjZW1lbnQnLFxuICAnbGVnYWN5JyxcbiAgJ21heCcsXG4gICdtYXhsZW5ndGgnLFxuICAnbWluJyxcbiAgJ21pbmxlbmd0aCcsXG4gICdtb2RlJyxcbiAgJ211bHRpcGxlJyxcbiAgJ25hbWUnLFxuICAncGF0dGVybicsXG4gICdwbGFjZWhvbGRlcicsXG4gICdyZWFkb25seScsXG4gICdyZXF1aXJlZCcsXG4gICdzaGFwZScsXG4gICdzaXplJyxcbiAgJ3NwZWxsY2hlY2snLFxuICAnc3RlcCcsXG4gICd0eXBlJyxcbiAgJ3ZhbHVlJyxcbl07XG5cbmNvbnN0IElOUFVUX01FVEhPRFMgPSBbJ3NldEZvY3VzJywgJ2dldElucHV0RWxlbWVudCddO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdpb24taW5wdXQnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9uby1pbnB1dHMtbWV0YWRhdGEtcHJvcGVydHlcbiAgaW5wdXRzOiBJTlBVVF9JTlBVVFMsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgdXNlRXhpc3Rpbmc6IElvbklucHV0LFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbn0pXG5leHBvcnQgY2xhc3MgSW9uSW5wdXQgZXh0ZW5kcyBWYWx1ZUFjY2Vzc29yIGltcGxlbWVudHMgT25Jbml0IHtcbiAgcHJvdGVjdGVkIGVsOiBIVE1MRWxlbWVudDtcbiAgY29uc3RydWN0b3IoYzogQ2hhbmdlRGV0ZWN0b3JSZWYsIHI6IEVsZW1lbnRSZWYsIHByb3RlY3RlZCB6OiBOZ1pvbmUsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHN1cGVyKGluamVjdG9yLCByKTtcbiAgICBkZWZpbmVDdXN0b21FbGVtZW50KCk7XG4gICAgYy5kZXRhY2goKTtcbiAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIHByb3h5T3V0cHV0cyh0aGlzLCB0aGlzLmVsLCBbJ2lvbklucHV0JywgJ2lvbkNoYW5nZScsICdpb25CbHVyJywgJ2lvbkZvY3VzJ10pO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgLyoqXG4gICAgICogRGF0YS1ib3VuZCBpbnB1dCBwcm9wZXJ0aWVzIGFyZSBzZXRcbiAgICAgKiBieSBBbmd1bGFyIGFmdGVyIHRoZSBjb25zdHJ1Y3Rvciwgc29cbiAgICAgKiB3ZSBuZWVkIHRvIHJ1biB0aGUgcHJveHkgaW4gbmdPbkluaXQuXG4gICAgICovXG4gICAgcHJveHlJbnB1dHMoSW9uSW5wdXQsIElOUFVUX0lOUFVUUyk7XG4gICAgcHJveHlNZXRob2RzKElvbklucHV0LCBJTlBVVF9NRVRIT0RTKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2lvbklucHV0JywgWyckZXZlbnQudGFyZ2V0J10pXG4gIGhhbmRsZUlvbklucHV0KGVsOiBIVE1MSW9uSW5wdXRFbGVtZW50KTogdm9pZCB7XG4gICAgdGhpcy5oYW5kbGVWYWx1ZUNoYW5nZShlbCwgZWwudmFsdWUpO1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHN1cGVyLnJlZ2lzdGVyT25DaGFuZ2UoKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgaW5wdXQgdHlwZSBpcyBgbnVtYmVyYCwgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSB2YWx1ZSB0byBhIG51bWJlclxuICAgICAgICAgKiB3aGVuIHRoZSB2YWx1ZSBpcyBub3QgZW1wdHkuIElmIHRoZSB2YWx1ZSBpcyBlbXB0eSwgd2Ugd2FudCB0byB0cmVhdFxuICAgICAgICAgKiB0aGUgdmFsdWUgYXMgbnVsbC5cbiAgICAgICAgICovXG4gICAgICAgIGZuKHZhbHVlID09PSAnJyA/IG51bGwgOiBwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIElvbklucHV0IGV4dGVuZHMgQ29tcG9uZW50cy5Jb25JbnB1dCB7XG4gIC8qKlxuICAgKiBUaGUgYGlvbklucHV0YCBldmVudCBpcyBmaXJlZCBlYWNoIHRpbWUgdGhlIHVzZXIgbW9kaWZpZXMgdGhlIGlucHV0J3MgdmFsdWUuXG5Vbmxpa2UgdGhlIGBpb25DaGFuZ2VgIGV2ZW50LCB0aGUgYGlvbklucHV0YCBldmVudCBpcyBmaXJlZCBmb3IgZWFjaCBhbHRlcmF0aW9uXG50byB0aGUgaW5wdXQncyB2YWx1ZS4gVGhpcyB0eXBpY2FsbHkgaGFwcGVucyBmb3IgZWFjaCBrZXlzdHJva2UgYXMgdGhlIHVzZXIgdHlwZXMuXG5cbkZvciBlbGVtZW50cyB0aGF0IGFjY2VwdCB0ZXh0IGlucHV0IChgdHlwZT10ZXh0YCwgYHR5cGU9dGVsYCwgZXRjLiksIHRoZSBpbnRlcmZhY2VcbmlzIFtgSW5wdXRFdmVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbnB1dEV2ZW50KTsgZm9yIG90aGVycyxcbnRoZSBpbnRlcmZhY2UgaXMgW2BFdmVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudCkuIElmXG50aGUgaW5wdXQgaXMgY2xlYXJlZCBvbiBlZGl0LCB0aGUgdHlwZSBpcyBgbnVsbGAuXG4gICAqL1xuICBpb25JbnB1dDogRXZlbnRFbWl0dGVyPEN1c3RvbUV2ZW50PElJb25JbnB1dElucHV0SW5wdXRFdmVudERldGFpbD4+O1xuICAvKipcbiAgICogVGhlIGBpb25DaGFuZ2VgIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgbW9kaWZpZXMgdGhlIGlucHV0J3MgdmFsdWUuXG5Vbmxpa2UgdGhlIGBpb25JbnB1dGAgZXZlbnQsIHRoZSBgaW9uQ2hhbmdlYCBldmVudCBpcyBvbmx5IGZpcmVkIHdoZW4gY2hhbmdlc1xuYXJlIGNvbW1pdHRlZCwgbm90IGFzIHRoZSB1c2VyIHR5cGVzLlxuXG5EZXBlbmRpbmcgb24gdGhlIHdheSB0aGUgdXNlcnMgaW50ZXJhY3RzIHdpdGggdGhlIGVsZW1lbnQsIHRoZSBgaW9uQ2hhbmdlYFxuZXZlbnQgZmlyZXMgYXQgYSBkaWZmZXJlbnQgbW9tZW50OlxuLSBXaGVuIHRoZSB1c2VyIGNvbW1pdHMgdGhlIGNoYW5nZSBleHBsaWNpdGx5IChlLmcuIGJ5IHNlbGVjdGluZyBhIGRhdGVcbmZyb20gYSBkYXRlIHBpY2tlciBmb3IgYDxpb24taW5wdXQgdHlwZT1cImRhdGVcIj5gLCBwcmVzc2luZyB0aGUgXCJFbnRlclwiIGtleSwgZXRjLikuXG4tIFdoZW4gdGhlIGVsZW1lbnQgbG9zZXMgZm9jdXMgYWZ0ZXIgaXRzIHZhbHVlIGhhcyBjaGFuZ2VkOiBmb3IgZWxlbWVudHNcbndoZXJlIHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gaXMgdHlwaW5nLlxuICAgKi9cbiAgaW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Q3VzdG9tRXZlbnQ8SUlvbklucHV0SW5wdXRDaGFuZ2VFdmVudERldGFpbD4+O1xuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIHRoZSBpbnB1dCBsb3NlcyBmb2N1cy5cbiAgICovXG4gIGlvbkJsdXI6IEV2ZW50RW1pdHRlcjxDdXN0b21FdmVudDxGb2N1c0V2ZW50Pj47XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIGlucHV0IGhhcyBmb2N1cy5cbiAgICovXG4gIGlvbkZvY3VzOiBFdmVudEVtaXR0ZXI8Q3VzdG9tRXZlbnQ8Rm9jdXNFdmVudD4+O1xufVxuIl19