import { Injectable } from '@angular/core';
import { createAnimation, getTimeGivenProgression } from '@ionic/core/components';
import * as i0 from "@angular/core";
export class AnimationController {
    /**
     * Create a new animation
     */
    create(animationId) {
        return createAnimation(animationId);
    }
    /**
     * EXPERIMENTAL
     *
     * Given a progression and a cubic bezier function,
     * this utility returns the time value(s) at which the
     * cubic bezier reaches the given time progression.
     *
     * If the cubic bezier never reaches the progression
     * the result will be an empty array.
     *
     * This is most useful for switching between easing curves
     * when doing a gesture animation (i.e. going from linear easing
     * during a drag, to another easing when `progressEnd` is called)
     */
    easingTime(p0, p1, p2, p3, progression) {
        return getTimeGivenProgression(p0, p1, p2, p3, progression);
    }
}
/** @nocollapse */ AnimationController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: AnimationController, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ AnimationController.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: AnimationController, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: AnimationController, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5pbWF0aW9uLWNvbnRyb2xsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb21tb24vc3JjL3Byb3ZpZGVycy9hbmltYXRpb24tY29udHJvbGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBRSxlQUFlLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQzs7QUFLbEYsTUFBTSxPQUFPLG1CQUFtQjtJQUM5Qjs7T0FFRztJQUNILE1BQU0sQ0FBQyxXQUFvQjtRQUN6QixPQUFPLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNILFVBQVUsQ0FBQyxFQUFZLEVBQUUsRUFBWSxFQUFFLEVBQVksRUFBRSxFQUFZLEVBQUUsV0FBbUI7UUFDcEYsT0FBTyx1QkFBdUIsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDOUQsQ0FBQzs7b0lBeEJVLG1CQUFtQjt3SUFBbkIsbUJBQW1CLGNBRmxCLE1BQU07NEZBRVAsbUJBQW1CO2tCQUgvQixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB0eXBlIHsgQW5pbWF0aW9uIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cyc7XG5pbXBvcnQgeyBjcmVhdGVBbmltYXRpb24sIGdldFRpbWVHaXZlblByb2dyZXNzaW9uIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBBbmltYXRpb25Db250cm9sbGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBhbmltYXRpb25cbiAgICovXG4gIGNyZWF0ZShhbmltYXRpb25JZD86IHN0cmluZyk6IEFuaW1hdGlvbiB7XG4gICAgcmV0dXJuIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRpb25JZCk7XG4gIH1cblxuICAvKipcbiAgICogRVhQRVJJTUVOVEFMXG4gICAqXG4gICAqIEdpdmVuIGEgcHJvZ3Jlc3Npb24gYW5kIGEgY3ViaWMgYmV6aWVyIGZ1bmN0aW9uLFxuICAgKiB0aGlzIHV0aWxpdHkgcmV0dXJucyB0aGUgdGltZSB2YWx1ZShzKSBhdCB3aGljaCB0aGVcbiAgICogY3ViaWMgYmV6aWVyIHJlYWNoZXMgdGhlIGdpdmVuIHRpbWUgcHJvZ3Jlc3Npb24uXG4gICAqXG4gICAqIElmIHRoZSBjdWJpYyBiZXppZXIgbmV2ZXIgcmVhY2hlcyB0aGUgcHJvZ3Jlc3Npb25cbiAgICogdGhlIHJlc3VsdCB3aWxsIGJlIGFuIGVtcHR5IGFycmF5LlxuICAgKlxuICAgKiBUaGlzIGlzIG1vc3QgdXNlZnVsIGZvciBzd2l0Y2hpbmcgYmV0d2VlbiBlYXNpbmcgY3VydmVzXG4gICAqIHdoZW4gZG9pbmcgYSBnZXN0dXJlIGFuaW1hdGlvbiAoaS5lLiBnb2luZyBmcm9tIGxpbmVhciBlYXNpbmdcbiAgICogZHVyaW5nIGEgZHJhZywgdG8gYW5vdGhlciBlYXNpbmcgd2hlbiBgcHJvZ3Jlc3NFbmRgIGlzIGNhbGxlZClcbiAgICovXG4gIGVhc2luZ1RpbWUocDA6IG51bWJlcltdLCBwMTogbnVtYmVyW10sIHAyOiBudW1iZXJbXSwgcDM6IG51bWJlcltdLCBwcm9ncmVzc2lvbjogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbihwMCwgcDEsIHAyLCBwMywgcHJvZ3Jlc3Npb24pO1xuICB9XG59XG4iXX0=